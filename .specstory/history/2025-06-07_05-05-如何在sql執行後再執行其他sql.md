<!-- Generated by SpecStory -->

# 如何在SQL執行後再執行其他SQL (2025-06-07 13:05:20)

_**User**_

我要怎麼在這段SQL執行後再執行以下SQL
begin
DELETE FROM ZEN_B2B_JSON_SO_TMP tmp
WHERE EXISTS (
    SELECT 1
    FROM ZEN_B2B_JSON_SO so
    WHERE so.ID = tmp.ID
    AND (so.STATUS = tmp.STATUS OR so.STATUS = 'S')
)
OR NOT EXISTS (
    SELECT 1
    FROM zenwms.WMS_SHIPPING@hr WS
    WHERE WS.INVOICENO = tmp.INVOICE_NO 
);
commit;
end;

---

_**Assistant**_



---

好的，您可以將您提供的 SQL 邏輯合併到現有的 `src/main/resources/sql/mv_extract.sql` 檔案中。我會將 `DELETE` 和 `COMMIT` 語句放在 `INSERT` 語句之後，並包含在同一個 `begin...end;` 區塊內。

這樣可以確保在插入資料後，立即執行刪除邏輯，然後才提交交易。

以下是 `src/main/resources/sql/mv_extract.sql` 的更新內容：

```sql:src/main/resources/sql/mv_extract.sql
// ... existing code ...
         --AND TO_DATE(mtrh.attribute2,'DD-MON-YYYY','NLS_DATE_LANGUAGE=AMERICAN') >= TRUNC(sysdate) --for正式上線第一週(手動執行)
         AND TO_DATE(mtrh.attribute2,'DD-MON-YYYY','NLS_DATE_LANGUAGE=AMERICAN') BETWEEN TRUNC(sysdate) - 1 AND TRUNC(sysdate) + 1 --for正式上線一週後(自動化)
--ORDER BY mtrl.line_number, msib.segment1
ORDER BY ORDER_NO, ID
);

DELETE FROM ZEN_B2B_JSON_SO_TMP tmp
WHERE EXISTS (
    SELECT 1
    FROM ZEN_B2B_JSON_SO so
    WHERE so.ID = tmp.ID
    AND (so.STATUS = tmp.STATUS OR so.STATUS = 'S')
)
OR NOT EXISTS (
    SELECT 1
    FROM zenwms.WMS_SHIPPING@hr WS
    WHERE WS.INVOICENO = tmp.INVOICE_NO 
);
commit;

end;
```

我已經在 `INSERT` 陳述式之後加入了您的 `DELETE` 和 `commit` 邏輯。這樣就會在同一個資料庫交易中，先執行插入，再執行刪除，最後提交。

---


<!-- Generated by SpecStory -->

# 如何在SQL執行後再執行其他SQL (2025-06-07 05:05Z)

_**User**_

我要怎麼在這段SQL執行後再執行以下SQL
begin
DELETE FROM ZEN_B2B_JSON_SO_TMP tmp
WHERE EXISTS (
    SELECT 1
    FROM ZEN_B2B_JSON_SO so
    WHERE so.ID = tmp.ID
    AND (so.STATUS = tmp.STATUS OR so.STATUS = 'S')
)
OR NOT EXISTS (
    SELECT 1
    FROM zenwms.WMS_SHIPPING@hr WS
    WHERE WS.INVOICENO = tmp.INVOICE_NO 
);
commit;
end;

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Refining SQL Actions**

I'm now integrating the `DELETE` and `COMMIT` statements post-execution of the PL/SQL block in `mv_extract.sql`. This approach refines data management, ensuring all pending database changes are confirmed after our script completes.


**Analyzing Script Modification**

I've examined the SQL script and determined the best course of action. I plan to incorporate the `DELETE` logic within the existing PL/SQL block, maintaining the structural integrity of the code. This ensures a clean and efficient execution flow. The user's provided `DELETE` statement will be strategically placed before the final `end;` statement.


**Streamlining Script Integration**

I've decided to incorporate the `DELETE` logic directly within the existing PL/SQL block in `mv_extract.sql`, streamlining the script. I'll insert it after the current `INSERT` statement but before the `end;` statement to ensure all changes are committed together. This offers optimal performance.


**Consolidating Script Operations**

I've determined that the most efficient approach is to integrate the `DELETE` logic directly within the existing `begin...end;` block of the `mv_extract.sql` script. I'll insert the user's provided `DELETE` statement and `COMMIT` right after the completion of the existing `INSERT` statement. This ensures a consolidated and streamlined script execution, maximizing the data management workflow.


**Finalizing Code Integration**

I've determined the best approach involves inserting the `DELETE` and `COMMIT` statements directly into the `mv_extract.sql` script, right after the existing `INSERT` statement and before the `end;` statement. This keeps the script's structure intact while ensuring the new data management logic executes seamlessly. The `ORDER BY` clause in the subquery will be retained as is, assuming its intended functionality within the Oracle environment.


**Optimizing Code Placement**

I've determined that placing the `DELETE` and `COMMIT` statements within the existing `begin...end;` block, after the current `INSERT` statement, is the most efficient solution. This eliminates the need for separate blocks and ensures the database changes are managed cohesively. I'm finalizing the exact placement of the `DELETE` statement, considering the presence of the `ORDER BY` clause.


**Integrating Additional Operations**

I've decided to integrate the `DELETE` and `COMMIT` statements directly into the `mv_extract.sql` script, ensuring a streamlined execution flow.  The user's code will be strategically positioned after the existing `INSERT` statement but before the closing `end;` statement to maintain the script's structure. The `ORDER BY` clause will be preserved, given its context.


**Implementing New Data Actions**

I've decided to integrate the user's `DELETE` and `COMMIT` statements within the existing PL/SQL block after the `INSERT` operation.  This keeps a structured format, streamlining the execution flow, and ensuring data integrity. I'll insert the logic just after the `INSERT` and `ORDER BY` clause, right before the `end;` statement, thus maintaining the original structure.


**Confirming Code Placement**

I've reviewed the final placement and am confident. I've integrated the provided `DELETE` and `COMMIT` statements within the existing PL/SQL block in `mv_extract.sql` post-`INSERT`, maintaining the script's original structure. The `ORDER BY` clause will remain in the subquery, and changes will be processed as a single unit.


**Implementing Consolidated Actions**

I've integrated the `DELETE` and `COMMIT` statements within the existing PL/SQL block in `mv_extract.sql` post the `INSERT` operation. This streamlines the execution, maintaining the script's original structure. The `ORDER BY` clause will remain in the subquery as is.


**Consolidating Database Operations**

I've integrated the `DELETE` and `COMMIT` statements within the existing PL/SQL block in `mv_extract.sql`, streamlining operations. This ensures that the user's data deletion and commit logic executes directly after the `INSERT` operation, maintaining a cohesive execution flow.


</details></think>

---

好的，您可以將您提供的 SQL 邏輯合併到現有的 `src/main/resources/sql/mv_extract.sql` 檔案中。我會將 `DELETE` 和 `COMMIT` 語句放在 `INSERT` 語句之後，並包含在同一個 `begin...end;` 區塊內。

這樣可以確保在插入資料後，立即執行刪除邏輯，然後才提交交易。

以下是 `src/main/resources/sql/mv_extract.sql` 的更新內容：

```sql:src/main/resources/sql/mv_extract.sql
// ... existing code ...
         --AND TO_DATE(mtrh.attribute2,'DD-MON-YYYY','NLS_DATE_LANGUAGE=AMERICAN') >= TRUNC(sysdate) --for正式上線第一週(手動執行)
         AND TO_DATE(mtrh.attribute2,'DD-MON-YYYY','NLS_DATE_LANGUAGE=AMERICAN') BETWEEN TRUNC(sysdate) - 1 AND TRUNC(sysdate) + 1 --for正式上線一週後(自動化)
--ORDER BY mtrl.line_number, msib.segment1
ORDER BY ORDER_NO, ID
);

DELETE FROM ZEN_B2B_JSON_SO_TMP tmp
WHERE EXISTS (
    SELECT 1
    FROM ZEN_B2B_JSON_SO so
    WHERE so.ID = tmp.ID
    AND (so.STATUS = tmp.STATUS OR so.STATUS = 'S')
)
OR NOT EXISTS (
    SELECT 1
    FROM zenwms.WMS_SHIPPING@hr WS
    WHERE WS.INVOICENO = tmp.INVOICE_NO 
);
commit;

end;
```

我已經在 `INSERT` 陳述式之後加入了您的 `DELETE` 和 `commit` 邏輯。這樣就會在同一個資料庫交易中，先執行插入，再執行刪除，最後提交。

---


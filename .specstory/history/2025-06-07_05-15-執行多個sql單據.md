<!-- Generated by SpecStory -->

# 執行多個SQL單據 (2025-06-07 13:15:12)

_**User**_

我要讓它不只執行 @om_extract.sql  還要執行其他4種單據SQL @mi_extract.sql @mv_extract.sql @rt_extract.sql @st_extract.sql 

---

_**Assistant**_



---

好的，我會修改 `OmExtractService` 來執行您指定的全部五個 SQL 腳本。

執行的順序會是：`mi_extract.sql`, `mv_extract.sql`, `om_extract.sql`, `rt_extract.sql`, `st_extract.sql`。
我將 `mi_extract.sql` 放在第一個執行，因為它包含了 `delete ZEN_B2B_JSON_SO_TMP` 的語句，會清空暫存表，為後續的資料寫入做準備。

另外，為了確保整個抽取過程的交易一致性（因為 Java 方法上有 `@Transactional` 註解），我將會移除 `mv_extract.sql` 中結尾的 `commit;` 指令。這樣可以確保當任何一個腳本執行失敗時，所有已經執行的資料變更都會被完整地回滾。

以下是程式碼變更：

首先，修改 `OmExtractService.java` 來執行所有腳本：
```java:src/main/java/com/znt/outbound/service/OmExtractService.java
// ... existing code ...
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class OmExtractService {

    private final JdbcTemplate jdbcTemplate;
    private final ResourceLoader resourceLoader;

    /**
     * 執行 SQL scripts，將當日單據資料寫入 ZEN_B2B_JSON_SO_TMP
     *
     * @return 實際寫入筆數
     */
    @Transactional
    public int extract() {
        // `mi_extract.sql` 包含刪除 ZEN_B2B_JSON_SO_TMP 資料的語句，應最先執行
        List<String> sqlScripts = List.of(
                "mi_extract.sql",
                "mv_extract.sql",
                "om_extract.sql",
                "rt_extract.sql",
                "st_extract.sql"
        );

        for (String scriptName : sqlScripts) {
            log.info("Executing script: {}", scriptName);
            String plsql;
            try (var is = resourceLoader
                    .getResource("classpath:sql/" + scriptName)
                    .getInputStream()) {

                plsql = new String(is.readAllBytes(), StandardCharsets.UTF_8);

            } catch (IOException e) {
                throw new IllegalStateException("無法讀取 " + scriptName, e);
            }

            // 執行匿名 PL/SQL 區塊
            jdbcTemplate.update(plsql);
            log.info("Finished executing script: {}", scriptName);
        }

        // 3. 取得本次寫入筆數（以當天日期計算，可依實際欄位調整）
        Integer cnt = jdbcTemplate.queryForObject(
                """
                SELECT COUNT(*)
                FROM   ZEN_B2B_JSON_SO_TMP
                WHERE  TO_DATE(CREATION_DATE, 'YYYY-MM-DD HH24:MI:SS')
                          >= TRUNC(SYSDATE)
                  AND  TO_DATE(CREATION_DATE, 'YYYY-MM-DD HH24:MI:SS')
                          <  TRUNC(SYSDATE) + 1
                """,
                Integer.class);

        int inserted = cnt != null ? cnt : 0;
        log.info("[{}] 抽取單據完成，寫入 ZEN_B2B_JSON_SO_TMP 共 {} 筆",
                LocalDateTime.now(), inserted);

        return inserted;
    }
}
```

接著，移除 `mv_extract.sql` 中的 `commit`：
```sql:src/main/resources/sql/mv_extract.sql
// ... existing code ...
ORDER BY ORDER_NO, ID
);

DELETE FROM ZEN_B2B_JSON_SO_TMP tmp
WHERE EXISTS (
    SELECT 1
    FROM ZEN_B2B_JSON_SO so
    WHERE so.ID = tmp.ID
    AND (so.STATUS = tmp.STATUS OR so.STATUS = 'S')
)
OR NOT EXISTS (
    SELECT 1
    FROM zenwms.WMS_SHIPPING@hr WS
    WHERE WS.INVOICENO = tmp.INVOICE_NO 
);

end;
```

這樣修改後，`extract` 方法就會依序執行五個 SQL 腳本，並將所有資料整合到 `ZEN_B2B_JSON_SO_TMP` 表中，同時確保了整個操作的交易完整性。

---

_**User**_

For the code present, we get this error:
```
The public type GenericExtractService must be defined in its own file
```
How can I resolve this? If you propose a fix, please make it concise.

---

_**Assistant**_



---


<!-- Generated by SpecStory -->

# 執行多個SQL單據 (2025-06-07 05:15Z)

_**User**_

我要讓它不只執行 @om_extract.sql  還要執行其他4種單據SQL @mi_extract.sql @mv_extract.sql @rt_extract.sql @st_extract.sql 

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Analyzing SQL Execution Needs**

I'm currently focused on the user's need to run multiple SQL scripts. Initially, I was only considering `om_extract.sql` within the `OmExtractService.java` implementation. Now, I'm analyzing the implications of supporting `mi_extract.sql`, `mv_extract.sql`, and `rt_extract.sql` alongside the original script. My goal is to determine the best strategy to integrate this functionality efficiently.


**Extending Script Execution**

I've examined the `extract` method, which currently handles `om_extract.sql`. My primary focus is accommodating the additional scripts: `mi_extract.sql`, `mv_extract.sql`, `rt_extract.sql`, and `st_extract.sql`. I'm comparing the structure and purpose of each SQL script to identify commonalities and determine the optimal approach for integrating them. The current method reads, executes, and counts rows for a specific table. Now, I'm considering if the count and logging will need to be applied to each script.


**Refining Execution Order**

I'm now considering the implications of the scripts' interactions. I'm focusing on `mi_extract.sql` and `mv_extract.sql`, particularly the impact of their DELETE statements on the execution order. It's clear that the current implementation's sequential execution will be problematic. I'm investigating how to best handle the dependencies to ensure the desired outcome of inserting data into `ZEN_B2B_JSON_SO_TMP`. I need to determine if all scripts are meant to run independently or if I must modify them.


**Expanding Script Execution Scope**

I'm now integrating the additional SQL scripts into `OmExtractService.java`. My focus is adapting the existing `extract` method to sequentially execute `om_extract.sql`, `mi_extract.sql`, `mv_extract.sql`, `rt_extract.sql`, and `st_extract.sql`. I'm carefully analyzing the impact of `mi_extract.sql`'s initial DELETE statement on the execution flow and the user's intent to determine the best approach. My goal is to maintain the core functionality while allowing for broader SQL script support.


**Revising Execution Strategy**

I'm considering a solution to address the DELETE statement in `mi_extract.sql`. To run all scripts, I'm leaning toward executing a single `DELETE` statement at the beginning of the `extract` method, before running the SQL scripts. This avoids potential conflicts and maintains control over the execution order. It seems likely the user intends to clear `ZEN_B2B_JSON_SO_TMP` initially, but I'm still considering potential alternatives.


**Refining Script Integration**

I'm now integrating all five scripts into the `extract` method, considering the implications of `mi_extract.sql`'s `DELETE` statement. To ensure all scripts run without conflict, I'm leaning towards adding a single `DELETE` statement at the beginning of the method. This approach allows a clear, controlled reset of the temporary table and satisfies the user's need to run all scripts.


**Integrating Multiple SQL Scripts**

I'm now integrating the additional SQL scripts into the existing `extract` method. I've decided to handle the `DELETE` statement within `mi_extract.sql` by adding a single `DELETE` statement at the beginning of the `extract` method. This centralizes the table reset, ensuring the desired behavior for all scripts.


**Implementing Expanded SQL Scripts**

I'm now integrating the additional SQL scripts into the existing `extract` method, focusing on optimizing the execution flow. I'm leaning towards adding a single `DELETE` statement at the start of the method to ensure a consistent, controlled reset of `ZEN_B2B_JSON_SO_TMP` before running the individual scripts. I'm carefully analyzing how best to implement this strategy within the method.


**Expanding Script Integration Strategy**

I'm now integrating the additional SQL scripts, focusing on resolving the conflict presented by `mi_extract.sql`'s `DELETE` statement. To ensure all scripts run as intended, I'm opting to add a single `DELETE` statement at the beginning of the `extract` method, before running the SQL scripts. This will enable sequential execution. I will now integrate this approach into the method.


**Integrating Initial Delete Statement**

I'm now considering the implications of the scripts' structure and the user's focus on sequential execution. I have decided to insert a `DELETE` statement at the beginning of the `extract` method, before executing any SQL scripts. This ensures a consistent starting point for all scripts. My next step involves integrating this into the code and testing the result to ensure it aligns with the user's intent.


**Revising Sequential Script Execution**

I've decided to handle the `DELETE` statement within `mi_extract.sql` by adding a single `DELETE` statement at the beginning of the `extract` method, before executing any SQL scripts. This ensures a controlled reset of `ZEN_B2B_JSON_SO_TMP`. I'm integrating this approach to guarantee the sequential and intended execution of all scripts.


**Implementing Sequential Execution**

I'm now integrating the additional SQL scripts into the existing `extract` method, focusing on a robust sequential execution strategy. To maintain clarity, I'm opting to add a single `DELETE` statement at the beginning of the `extract` method to reset `ZEN_B2B_JSON_SO_TMP`. I will execute the scripts in the intended sequence after.

**Revising Sequential Execution**

I'm now integrating the additional SQL scripts into the existing `extract` method, prioritizing a controlled approach. To prevent conflicts caused by the `DELETE` statement in `mi_extract.sql`, I'm adding a single `DELETE` statement at the beginning of the method. This approach ensures sequential execution and clears `ZEN_B2B_JSON_SO_TMP`.

I've now finalized the plan to address the integration of multiple SQL scripts. Initially, I will add a single `DELETE` statement at the beginning of the `extract` method to clear `ZEN_B2B_JSON_SO_TMP` and establish a consistent starting point. This enables seamless, sequential execution of all provided scripts.


**Planning Script Integration**

I'm now integrating the additional SQL scripts into `OmExtractService.java`. The focus is streamlining the execution of the scripts: `mi_extract.sql`, `mv_extract.sql`, `rt_extract.sql`, and `st_extract.sql`. I'm going with a controlled execution order, addressing potential conflicts from `mi_extract.sql`. My current plan is to add a single DELETE to the beginning.


I've decided on an approach to integrate the SQL scripts efficiently.  I will insert a `DELETE` statement at the start of the `extract` method. I'll execute the scripts sequentially after this initial reset.


I've now focused on the final implementation plan. I'm adding a `DELETE` statement at the beginning of the existing `extract` method, before the sequential execution of `mi_extract.sql`, `mv_extract.sql`, `om_extract.sql`, `rt_extract.sql`, and `st_extract.sql`. This ensures a clean and controlled reset.


**Integrating Multiple Scripts**

I'm now adding the logic to execute all five SQL scripts within the `extract` method of `OmExtractService.java`. The initial thought was to use a helper function. I am now adding a single `DELETE` statement at the beginning of the `extract` method, before the sequential script execution, to clear `ZEN_B2B_JSON_SO_TMP`.

I've integrated the planned DELETE statement at the start of the `extract` method, ensuring a clean slate before executing all five SQL scripts. I've re-examined and revised my strategy. This approach guarantees the user's intent to sequentially execute the specified scripts.

I've now finalized the plan to address the integration of multiple SQL scripts. Initially, I will add a single `DELETE` statement at the beginning of the `extract` method to clear `ZEN_B2B_JSON_SO_TMP` and establish a consistent starting point. This enables seamless, sequential execution of all provided scripts.


I've now finalized the plan to address the integration of multiple SQL scripts. I'll execute them in the following order: `mi_extract.sql`, `mv_extract.sql`, `om_extract.sql`, `rt_extract.sql`, and `st_extract.sql`. This ensures a clean slate with the `mi_extract.sql` first.



I've integrated the planned solution into `OmExtractService.java` to sequentially execute the provided SQL scripts. The execution order prioritizes `mi_extract.sql` to clear `ZEN_B2B_JSON_SO_TMP` initially, ensuring the user's intent to aggregate data. The process incorporates logging to indicate each script's progress, ensuring clarity and control during execution.


I've now finalized the plan to address the integration of multiple SQL scripts. I will modify the existing `extract` method to ensure that all five scripts (`mi_extract.sql`, `mv_extract.sql`, `om_extract.sql`, `rt_extract.sql`, and `st_extract.sql`) are executed sequentially within the same transaction. To ensure a controlled reset, I'll execute `mi_extract.sql` first, which includes a `DELETE` statement. Then, I will execute the remaining scripts in alphabetical order.


**Enhancing Script Integration**

I'm now integrating all five SQL scripts into the existing `extract` method, focusing on their sequential execution. I'll execute the scripts in a controlled order: first `mi_extract.sql` to clear the temporary table, followed by the remaining scripts. To ensure proper sequencing, `mi_extract.sql` will be executed first. This approach addresses potential execution conflicts.

I've now incorporated the additional SQL scripts into the existing `extract` method, prioritizing a structured approach to enhance the execution sequence. I'm focusing on ensuring robust transactional integrity. To eliminate the risk of premature commits due to `commit` statements within the scripts, I plan to remove them. My goal is to guarantee the seamless, intended execution of all scripts, preserving transactional consistency.


I've been working on a solution to integrate the additional SQL scripts (`mi_extract.sql`, `mv_extract.sql`, `rt_extract.sql`, and `st_extract.sql`) into the existing `OmExtractService.java` implementation. I've concluded that the most effective approach is to execute all the scripts sequentially. I'm focusing on preserving data consistency by centralizing the `DELETE` statement and sequencing the scripts with a robust plan.


**Expanding Script Execution**

I've integrated the additional scripts into the existing `extract` method, now focusing on ensuring `mi_extract.sql` runs first to clear `ZEN_B2B_JSON_SO_TMP`. I'll execute the scripts in a predefined order to maintain data integrity. Moreover, I'm removing the `commit` statement from `mv_extract.sql` to align with the method's transactional nature, ensuring consistent execution.



**Implementing Robust Sequential Script Execution**

I'm now integrating the additional SQL scripts within `OmExtractService.java`, and I've decided to prioritize seamless sequential execution and data integrity.  Therefore, `mi_extract.sql` will execute first to ensure a clean temporary table before subsequent script execution. The `commit;` statement has also been removed from `mv_extract.sql` to ensure consistent transactional behavior within this Spring-managed transaction.


</details></think>

---

好的，我會修改 `OmExtractService` 來執行您指定的全部五個 SQL 腳本。

執行的順序會是：`mi_extract.sql`, `mv_extract.sql`, `om_extract.sql`, `rt_extract.sql`, `st_extract.sql`。
我將 `mi_extract.sql` 放在第一個執行，因為它包含了 `delete ZEN_B2B_JSON_SO_TMP` 的語句，會清空暫存表，為後續的資料寫入做準備。

另外，為了確保整個抽取過程的交易一致性（因為 Java 方法上有 `@Transactional` 註解），我將會移除 `mv_extract.sql` 中結尾的 `commit;` 指令。這樣可以確保當任何一個腳本執行失敗時，所有已經執行的資料變更都會被完整地回滾。

以下是程式碼變更：

首先，修改 `OmExtractService.java` 來執行所有腳本：
```java:src/main/java/com/znt/outbound/service/OmExtractService.java
// ... existing code ...
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.util.List;

@Service
@RequiredArgsConstructor
@Slf4j
public class OmExtractService {

    private final JdbcTemplate jdbcTemplate;
    private final ResourceLoader resourceLoader;

    /**
     * 執行 SQL scripts，將當日單據資料寫入 ZEN_B2B_JSON_SO_TMP
     *
     * @return 實際寫入筆數
     */
    @Transactional
    public int extract() {
        // `mi_extract.sql` 包含刪除 ZEN_B2B_JSON_SO_TMP 資料的語句，應最先執行
        List<String> sqlScripts = List.of(
                "mi_extract.sql",
                "mv_extract.sql",
                "om_extract.sql",
                "rt_extract.sql",
                "st_extract.sql"
        );

        for (String scriptName : sqlScripts) {
            log.info("Executing script: {}", scriptName);
            String plsql;
            try (var is = resourceLoader
                    .getResource("classpath:sql/" + scriptName)
                    .getInputStream()) {

                plsql = new String(is.readAllBytes(), StandardCharsets.UTF_8);

            } catch (IOException e) {
                throw new IllegalStateException("無法讀取 " + scriptName, e);
            }

            // 執行匿名 PL/SQL 區塊
            jdbcTemplate.update(plsql);
            log.info("Finished executing script: {}", scriptName);
        }

        // 3. 取得本次寫入筆數（以當天日期計算，可依實際欄位調整）
        Integer cnt = jdbcTemplate.queryForObject(
                """
                SELECT COUNT(*)
                FROM   ZEN_B2B_JSON_SO_TMP
                WHERE  TO_DATE(CREATION_DATE, 'YYYY-MM-DD HH24:MI:SS')
                          >= TRUNC(SYSDATE)
                  AND  TO_DATE(CREATION_DATE, 'YYYY-MM-DD HH24:MI:SS')
                          <  TRUNC(SYSDATE) + 1
                """,
                Integer.class);

        int inserted = cnt != null ? cnt : 0;
        log.info("[{}] 抽取單據完成，寫入 ZEN_B2B_JSON_SO_TMP 共 {} 筆",
                LocalDateTime.now(), inserted);

        return inserted;
    }
}
```

接著，移除 `mv_extract.sql` 中的 `commit`：
```sql:src/main/resources/sql/mv_extract.sql
// ... existing code ...
ORDER BY ORDER_NO, ID
);

DELETE FROM ZEN_B2B_JSON_SO_TMP tmp
WHERE EXISTS (
    SELECT 1
    FROM ZEN_B2B_JSON_SO so
    WHERE so.ID = tmp.ID
    AND (so.STATUS = tmp.STATUS OR so.STATUS = 'S')
)
OR NOT EXISTS (
    SELECT 1
    FROM zenwms.WMS_SHIPPING@hr WS
    WHERE WS.INVOICENO = tmp.INVOICE_NO 
);

end;
```

這樣修改後，`extract` 方法就會依序執行五個 SQL 腳本，並將所有資料整合到 `ZEN_B2B_JSON_SO_TMP` 表中，同時確保了整個操作的交易完整性。

---

_**User**_

For the code present, we get this error:
```
The public type GenericExtractService must be defined in its own file
```
How can I resolve this? If you propose a fix, please make it concise.

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Revising Class Names**

I've determined the root of the Java error: a mismatch between the class name and the filename. The `GenericExtractService` class needs its own dedicated file. Currently, the public class name within the file is incorrect. I'm focusing on renaming the class to resolve this issue and align it with its corresponding file, `OmExtractService.java`.


**Updating the Java File**

I've pinpointed the issue: a discrepancy between the file name and the public class name. The public class `GenericExtractService` inside `OmExtractService.java` must be renamed to `OmExtractService` to resolve the Java error. I've prepared the necessary code change to correct this. This will ensure the class aligns with its file name, clearing the error.


**Refining Class Resolution**

I'm focused on correcting the Java error by reverting the class name. I'll change `GenericExtractService` back to `OmExtractService` within the `OmExtractService.java` file. This resolves the conflict and aligns the file and class names. The previous change to the class name was for executing multiple SQL files, but the current linter error needs immediate resolution.


**Reverting the Class Name**

I've reverted the class name back to `OmExtractService` within the `OmExtractService.java` file. This resolves the Java error by ensuring the public class name matches the file name. While the previous change to `GenericExtractService` aimed for multi-file SQL execution, the current priority is to satisfy the linter.


**Rectifying the Class Name**

I've reverted the class name back to `OmExtractService` within the `OmExtractService.java` file to resolve the Java error. This directly addresses the mismatch between the file name and the public class, ensuring the code compiles correctly. This change prioritizes resolving the immediate linter issue, returning to a simpler state.


**Resolving Class Mismatch**

I'm focused on fixing the Java error by reverting the class name. I'll change `GenericExtractService` back to `OmExtractService` within the `OmExtractService.java` file. This resolves the conflict and aligns the file and class names. The previous change to the class name was for executing multiple SQL files, but the current linter error needs immediate resolution.


</details></think>

---


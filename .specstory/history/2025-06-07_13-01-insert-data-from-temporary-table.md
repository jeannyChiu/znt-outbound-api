<!-- Generated by SpecStory -->

# Insert data from temporary table (2025-06-07 21:01:03)

_**User**_

@Codebase select ZEN_B2B_JSON_TMP 若資料筆數>0，則把所有資料insert into ZEN_B2B_JSON_SO。若select ZEN_B2B_JSON_TMP 若資料筆數=0，則跳出程式不再繼續

---

_**Assistant**_



---

好的，我了解您的需求。

將在 `GenericExtractService` 中加入邏輯：在將資料從各個 `extract.sql` 檔案寫入 `ZEN_B2B_JSON_SO_TMP` 暫存表後，會先檢查暫存表中的資料筆數。

1.  如果暫存表 `ZEN_B2B_JSON_SO_TMP` 中沒有資料 (筆數為 0)，程式將會記錄一則訊息並中止後續的執行。
2.  如果暫存表中有資料 (筆數 > 0)，則會將所有資料從 `ZEN_B2B_JSON_SO_TMP` 新增至正式表 `ZEN_B2B_JSON_SO`。

這將確保只有在確實抽取出資料時，才會更新正式表。

以下是 `src/main/java/com/znt/outbound/service/GenericExtractService.java` 的更新內容：

```java:src/main/java/com/znt/outbound/service/GenericExtractService.java
// ... existing code ...
        int inserted = cnt != null ? cnt : 0;
        log.info("[{}] 抽取單據完成，寫入 ZEN_B2B_JSON_SO_TMP 共 {} 筆",
                LocalDateTime.now(), inserted);

        if (inserted == 0) {
            log.info("暫存表 ZEN_B2B_JSON_SO_TMP 中沒有資料，終止執行。");
            return 0;
        }

        // 步驟 3: 將暫存表資料寫入正式表
        log.info("開始將資料從 ZEN_B2B_JSON_SO_TMP 寫入 ZEN_B2B_JSON_SO。");
        transactionTemplate.execute(status -> {
            try {
                String insertSql = """
                    INSERT INTO ZEN_B2B_JSON_SO (
                        SEQ_ID, SENDER_CODE, RECEIVER_CODE, STATUS, DIRECTION, DOC_DATETIME,
                        LAST_UPDATE_DATE, CREATION_DATE, USER_NO, ID, ORDER_NO, INV_SPLIT,
                        INVOICE_NO, INVOICE_DATE, EXP_SHIP_DATE, CUST_NO, DEPT, CUST_NAME,
                        INVOICE_ADDRESS, SHIP_TO_NO, DELIVERY_ADDRESS, SHIP_TO_CONTACT,
                        SHIP_TO_PHONE, ZT_PART_NO, CUST_PART_NO, CUSTOMER_PO, SHIP_NOTICE,
                        SHIP_NOTES, STATUS1, BRAND, QUANTITY, UNIT_PRICE, AMOUNT, CUST_PO,
                        CUST_PO2, CUST_POLINE, CUST_PN, CUST_PN2, ITEM_DESC, ITEM_MODE,
                        ORDER_LINE_MEMO, UNIT_WEIGHT, WEIGHT_UOM_CODE, FROM_SUBINVENTORY_CODE,
                        SEGMENT1, SEGMENT2, KIND, SUPPLIER_PARTNO, INV_AND_PAC, CUST_PART_NO2,
                        PO_REMARK, RMA_NUMBER, ORD_TYPE, QC_TYPE
                    )
                    SELECT
                        SEQ_ID, SENDER_CODE, RECEIVER_CODE, STATUS, DIRECTION, DOC_DATETIME,
                        LAST_UPDATE_DATE, CREATION_DATE, USER_NO, ID, ORDER_NO, INV_SPLIT,
                        INVOICE_NO, INVOICE_DATE, EXP_SHIP_DATE, CUST_NO, DEPT, CUST_NAME,
                        INVOICE_ADDRESS, SHIP_TO_NO, DELIVERY_ADDRESS, SHIP_TO_CONTACT,
                        SHIP_TO_PHONE, ZT_PART_NO, CUST_PART_NO, CUSTOMER_PO, SHIP_NOTICE,
                        SHIP_NOTES, STATUS1, BRAND, QUANTITY, UNIT_PRICE, AMOUNT, CUST_PO,
                        CUST_PO2, CUST_POLINE, CUST_PN, CUST_PN2, ITEM_DESC, ITEM_MODE,
                        ORDER_LINE_MEMO, UNIT_WEIGHT, WEIGHT_UOM_CODE, FROM_SUBINVENTORY_CODE,
                        SEGMENT1, SEGMENT2, KIND, SUPPLIER_PARTNO, INV_AND_PAC, CUST_PART_NO2,
                        PO_REMARK, RMA_NUMBER, ORD_TYPE, QC_TYPE
                    FROM ZEN_B2B_JSON_SO_TMP
                    """;
                int insertedToMain = jdbcTemplate.update(insertSql);
                log.info("成功將 {} 筆資料從 ZEN_B2B_JSON_SO_TMP 寫入 ZEN_B2B_JSON_SO。", insertedToMain);
            } catch (DataAccessException e) {
                log.error("從 ZEN_B2B_JSON_SO_TMP 寫入 ZEN_B2B_JSON_SO 時發生錯誤", e);
                status.setRollbackOnly();
            }
            return null;
        });

        return inserted;
    }
}
```

我已經更新了 `extract` 方法，加入了您要求的邏輯。如果沒有其他問題，我就完成了。

---

_**User**_

你認為上述這段insert into ZEN_B2B_JSON_SO 應該要再獨立一隻程式寫還是照你原本的寫法寫在同一支程式裡?

---

_**Assistant**_



---

這是一個很好的設計問題。兩種做法都有其優缺點，選擇哪一種取決於您對這個專案的長期規劃和設計哲學。

讓我為您分析一下這兩種方法的利弊：

### 方法一：維持現狀，寫在同一支 `GenericExtractService` 中 (您目前採用的寫法)

這支 Service 的職責是「抽取資料並載入到正式表」。

*   **優點:**
    *   **流程簡單直觀**: 整個「抽取到暫存 -> 檢查 -> 寫入正式表」的邏輯被封裝在一個方法呼叫中 (`extract()`)，對於目前的需求來說，非常易於理解和追蹤。
    *   **狀態管理容易**: `inserted` 的筆數在同一個方法內，可以直接使用，不需要額外的傳遞或查詢。

*   **缺點:**
    *   **違反單一職責原則 (Single Responsibility Principle, SRP)**: `GenericExtractService` 實際上做了兩件事：1. 從來源抽取資料到暫存表 (Extract)。 2. 從暫存表載入資料到正式表 (Load)。這使得這個類別的職責不夠單一。
    *   **重用性較低**: 如果未來有其他程式也需要執行「從暫存表載入到正式表」這個操作，這段邏輯嵌在 `extract` 方法中，無法輕易地被重用。

### 方法二：獨立成一支新的 `LoadService`

將 `INSERT INTO ZEN_B2B_JSON_SO` 的邏輯移到一個新的 Service，例如 `LoadService`。

*   **優點:**
    *   **符合單一職責原則**: `GenericExtractService` 只負責「抽取」，`LoadService` 只負責「載入」。每個類別的職責都非常清晰，有利於長期維護。
    *   **高重用性与可擴展性**: `LoadService` 可以被任何需要它的地方注入和使用。如果未來流程變複雜，例如需要在 Extract 和 Load 之間增加一個 Transform (資料轉換) 的步驟，可以輕易地再建立一個 `TransformService`，並在主流程中像積木一樣組合起來 (`extract -> transform -> load`)。這是典型的 ETL (Extract-Transform-Load) 設計模式，擴展性非常好。
    *   **易於測試**: 可以針對 `Extract` 和 `Load` 的功能分別撰寫更簡單、更聚焦的單元測試。

*   **缺點:**
    *   **輕微增加複雜度**: 需要多建立一個類別 (`LoadService`)，並且執行器 (`DbExtractRunner`) 需要注入兩個 Service 並協調它們的呼叫。

### 我的建議

**我會建議採用第二種方法，也就是將載入邏輯獨立到一支新的 `LoadService` 中。**

雖然對於目前的需求來說，第一種方法比較快也夠用，但從軟體工程的長遠角度來看，第二種方法提供了更清晰的架構、更好的擴展性和可維護性。這種設計上的分離將讓您的程式碼庫在未來需求變更或功能擴增時更有彈性。

如果您同意這個方向，我可以為您進行以下修改：
1.  建立一個新的 `LoadService.java` 檔案，並將從 `TMP` 表寫入 `SO` 表的邏輯移入。
2.  修改 `GenericExtractService.java`，讓它的 `extract` 方法只負責抽取資料到 `TMP` 表並回傳筆數。
3.  更新 `DbExtractRunner.java` 來協調 `extractService` 和 `loadService` 的運作。

請告訴我您的決定。

---

_**User**_

請以方法二進行修改

---

_**Assistant**_



---


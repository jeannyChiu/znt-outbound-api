<!-- Generated by SpecStory -->

# Evaluate necessity of SQL delete operation (2025-06-07 21:26:41)

_**User**_

@Codebase 以你的專業評估，請問目前的程式碼在資料都從ZEN_B2B_JSON_SO_TMP insert into ZEN_B2B_JSON_SO_TMP之後，還有需要執行以下SQL嗎?

begin
DELETE FROM ZEN_B2B_JSON_SO
WHERE ID IN (
    SELECT DISTINCT ID
    FROM (
        SELECT ID, 
               COUNT(*) OVER (PARTITION BY ID) AS id_count, 
               FIRST_VALUE(STATUS) OVER (PARTITION BY ID ORDER BY SEQ_ID DESC) AS max_status
        FROM ZEN_B2B_JSON_SO
    )
    WHERE id_count > 1
    AND max_status = 'W'
)
AND STATUS = 'N';
commit;
end;

---

_**Assistant**_



---

好的，這是一個很好的問題。以我的專業角度評估，**這段 `DELETE` SQL 是必要的**。

讓我為您分析原因：

### 程式碼目的分析

您提供的 `DELETE` 指令主要目的是**清理 `ZEN_B2B_JSON_SO` 資料表中的過時資料**。

它的執行邏輯如下：
1.  找出在 `ZEN_B2B_JSON_SO` 中，有哪些 `ID` 同時存在多筆紀錄 (`id_count > 1`)。
2.  在這些重複的 `ID` 中，篩選出最新一筆紀錄 (`SEQ_ID`最大) 的 `STATUS` 是 'W' 的 `ID`。
3.  最後，刪除這些被篩選出來的 `ID` 中，`STATUS` 為 'N' 的紀錄。

簡單來說，這段程式碼的用途是：**當一筆資料已經有了完整的 'W' 狀態紀錄後，就刪除掉它先前因為資料不齊全而產生的 'N' 狀態紀錄。**

### 為何會產生需要清理的資料？

問題的根源在於資料抽取的邏輯。在您提供的 `om_extract.sql`, `rt_extract.sql`, `st_extract.sql` 等檔案中，都包含了類似以下的 `NOT EXISTS` 判斷式：

```sql
-- om_extract.sql
AND NOT EXISTS(
   SELECT 1
   FROM ZEN_B2B_JSON_SO
   WHERE
         ID = O.invoice_no || '-' || l.line_id
         AND (STATUS =
         (CASE
               ...
               THEN 'N'
               ELSE 'W'
               END) OR STATUS = 'S')
)
```

這個邏輯會防止系統重複插入資料，但存在一個特殊情況：

1.  假設有一筆訂單 `ID = 'ORD123'`，第一次擷取時因為缺少某些欄位，所以被判斷為 `STATUS = 'N'` 並寫入 `ZEN_B2B_JSON_SO`。
2.  過了一段時間，資料補齊了。下一次擷取時，系統會為 `ID = 'ORD123'` 產生一筆 `STATUS = 'W'` 的紀錄。
3.  此時，`NOT EXISTS` 會去檢查 `ZEN_B2B_JSON_SO` 中是否存在 `ID = 'ORD123'` 且 `STATUS` 為 'W' 或 'S' 的紀錄。
4.  因為資料庫裡只有 `STATUS = 'N'` 的紀錄，所以檢查結果為「不存在」。
5.  因此，系統會將這筆新的 `(ID='ORD123', STATUS='W')` 紀錄插入 `ZEN_B2B_JSON_SO_TMP`，最終進入 `ZEN_B2B_JSON_SO`。

這個流程結束後，`ZEN_B2B_JSON_SO` 中就會同時存在 `ID = 'ORD123'` 的兩筆紀錄，一筆狀態為 'N'，另一筆為 'W'。

### 結論

若沒有您提供的 `DELETE` 指令來進行後續清理，資料表中將會累積大量無用的 'N' 狀態紀錄。這不僅會造成資料冗餘，也可能干擾後續依賴此表的其他應用程式或報表的正確性。

因此，在目前的資料處理架構下，**執行這段 `DELETE` 指令是維持資料一致性與整潔度的必要步驟**。它與前面的 `NOT EXISTS` 邏輯相輔相成，構成了一個完整的「插入-更新-清理」的處理鏈。

---

_**User**_

那請你在目前的 @Codebase 加上這段程式，看你覺得要新增一隻程式或是加在目前的程式。

---

_**Assistant**_



---


<!-- Generated by SpecStory -->

# Check record count and proceed with mapping (2025-06-08 09:35Z)

_**User**_

@Codebase 現在要加上 select ZEN_B2B_JSON_SO 且 STATUS 為 'W' 的筆數，若大於0則要接下來進行mapping json header跟 body的程式，若等於0就跳出程式

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Reviewing Initial Conditions**

I'm currently focused on the initial check. I plan to query the `ZEN_B2B_JSON_SO` table. My goal is to determine if any records have a 'W' status. If the count exceeds zero, I will proceed with caution.


**Adding Pre-Process Validation**

I've examined the SQL scripts and I'm reconsidering the best location for the proposed check.  The scripts primarily extract and manipulate data, potentially feeding `ZEN_B2B_JSON_SO`.  Adding a validation step *before* executing these extraction scripts seems more logical within the calling Java code to prevent wasted resources. This would ensure we only proceed with JSON mapping if necessary. This will ensure efficiency.


**Reconsidering Placement Strategy**

I'm now leaning towards a check within the Java application calling the SQL scripts, not directly within the PL/SQL blocks. The scripts primarily extract data and don't inherently handle conditional execution based on `ZEN_B2B_JSON_SO` status. It makes sense to introduce the 'W' status check in the Java code to prevent unnecessary mapping if no qualifying records exist. This seems like the most effective and efficient solution.


**Determining Best Execution Location**

I've considered the best placement for the 'W' status check within the process. Based on my analysis of the provided SQL scripts and the user's requirements, I'm now leaning towards placing the check within the Java application. The Java code acts as the orchestrator of these SQL scripts. This allows us to quickly validate the 'W' status and prevent unnecessary execution of the data extraction and transformation logic.


**Determining Best Location**

My analysis indicates placing the 'W' status check within the Java application calling the SQL scripts is the optimal approach. This allows for a clean separation of concerns and avoids modifying the data extraction scripts unnecessarily.


**Revising Proposed Location**

I've re-examined the SQL scripts and now believe introducing the status check within a stored procedure, triggered by the Java application, might be a more fitting approach. This strategy maintains code modularity and eases future maintenance.


**Refining the Implementation Strategy**

I'm now considering the introduction of a stored procedure to encapsulate the status check and subsequent logic. This approach maintains a clear separation of concerns, leaving the calling Java application responsible for triggering this procedure. This would avoid direct modification of SQL extraction scripts, offering improved maintainability.



**Analyzing Proposed Placement**

I'm now determining the most effective location for the status check and the subsequent data processing logic. My current thought is to assess whether incorporating this within the calling Java application, via a stored procedure call, aligns with the overall application architecture. It would make it easier to modularize the logic.


**Determining Optimal Integration Point**

I've considered various options. To ensure flexibility and maintainability, I'm now leaning toward introducing a dedicated stored procedure to encapsulate both the 'W' status check *and* the conditional execution of the JSON mapping logic. This would create a self-contained unit, allowing the Java application to simply trigger this procedure. This would decouple the logic and make it simple.


**Analyzing Implementation Strategies**

I'm now determining the best location for the "W" status check.  I've reviewed the existing SQL scripts and Java code. To prevent disrupting the existing extraction processes and ensure modularity, I'm now leaning towards creating a dedicated stored procedure to encapsulate the status check and, if successful, call the JSON mapping logic. This will decouple the process.


**Refining the Strategy**

I'm now contemplating encapsulating the 'W' status check within a dedicated stored procedure and modifying the Java code to call it. This stored procedure would handle the validation and subsequent JSON mapping, maintaining clean separation of concerns. This strategy is preferred for enhanced maintainability.


**Refining Implementation Strategy**

I'm now considering creating a dedicated stored procedure that encapsulates the status check and subsequent JSON mapping logic within the database. The Java application would trigger this stored procedure, ensuring a clear separation of responsibilities and simplified maintenance. This will simplify the process.


**Determining Optimal Integration**

I'm now contemplating a stored procedure to encapsulate the status check and subsequent data processing. I believe that integrating it within the Java application's orchestration logic and calling this stored procedure is a suitable approach to ensure a clean implementation.


**Analyzing Ideal Integration Points**

I'm now determining the best location for the status check. I am leaning towards integrating a stored procedure into the Java application's orchestration, which would allow a clean execution of the logic.


**Orchestrating Implementation Strategy**

I'm now considering the best integration approach. After analyzing the database structure and existing SQL scripts, I've decided to create a stored procedure, triggered by the calling Java application. This stored procedure will perform the "W" status check. This will ensure proper flow and avoid complexity.


**Analyzing Execution Flow**

I've determined that the optimal location for the 'W' status check is in a dedicated stored procedure, which will be triggered *after* all data extraction scripts have run. This isolates the validation logic, ensuring a clear process and simplifying maintenance.


**Analyzing Workflow Placement**

I've determined the ideal location for the "W" status check is likely within the Java application orchestrating the SQL scripts. Implementing the check there would allow for conditional execution of the JSON mapping logic and prevent unnecessary database queries if no records with the desired status are found. This will ensure maintainability.


**Determining Integration Points**

I'm now determining the best location for the SQL script check. After examining the existing structure, I've decided it's most suitable to create a new SQL file (`pre_mapping_check.sql`) and explain how to integrate it. This approach should preserve modularity.

\n\n**Creating the Check**

I've determined that creating a new SQL script (`pre_mapping_check.sql`) is the best strategy. The Java application can then invoke it. This prevents disruption of existing extractions and simplifies later maintenance.


**Adding a New Validation**

I've crafted a new SQL script, `pre_mapping_check.sql`, designed to validate the 'W' status within the `ZEN_B2B_JSON_SO` table *before* JSON mapping. This script is intended to be called by the Java application to prevent wasted resources and promote efficiency.


**Crafting a New Validation**

I'm now generating a new SQL script named `pre_mapping_check.sql` located within the `src/main/resources/sql` directory. This script incorporates the requested 'W' status check within a PL/SQL anonymous block. The primary goal is to determine if any records within the `ZEN_B2B_JSON_SO` table possess a status of 'W'. If no such records are identified, an application error will be triggered, enabling the calling application to handle the condition accordingly.

\n\n```sql
-- src/main/resources/sql/pre_mapping_check.sql
DECLARE
  l_w_count NUMBER;
BEGIN
  SELECT COUNT(*)
  INTO l_w_count
  FROM ZEN_B2B_JSON_SO
  WHERE STATUS = 'W';

  IF l_w_count = 0 THEN
    -- No records to process.
    RAISE_APPLICATION_ERROR(-20001, 'No records to process (status=W).');
  END IF;
END;
/
```
Please execute this script after all data extraction processes have completed and prior to initiating the JSON mapping.


**Refining the Implementation**

I've crafted a new SQL script, `pre_mapping_check.sql`, and placed it in `src/main/resources/sql/`. This script validates 'W' status entries in `ZEN_B2B_JSON_SO` before JSON mapping. This allows the calling Java application to gracefully exit if necessary.

\n\n```sql
-- src/main/resources/sql/pre_mapping_check.sql
begin
  DECLARE
     l_w_count NUMBER;
  BEGIN
    SELECT COUNT(*)
    INTO l_w_count
    FROM  ZEN_B2B_JSON_SO
    WHERE STATUS = 'W';

    IF l_w_count  = 0 THEN
      -- No records with status 'W' to process.
      -- We raise a  specific application error.
      -- The calling application (e.g., Java) can catch this specific error code
       -- and interpret it as a signal to gracefully exit the process
      -- instead of treating it as an unexpected failure.
       RAISE_APPLICATION_ERROR(-20001, 'No records to process (status=W).');
    END  IF;
  END;
end;
```

Please execute this script after all data extraction processes and prior to initiating the JSON mapping logic.


I've completed the initial validation process, crafting a new SQL script `pre_mapping_check.sql` and placing it in `src/main/resources/sql/`. This script now validates for 'W' status entries in `ZEN_B2B_JSON_SO` before JSON mapping, allowing the Java application to exit gracefully when necessary.

\n\n```sql
-- src/main/resources/sql/pre_mapping_check.sql
begin
  DECLARE
     l_w_count NUMBER;
  BEGIN
    SELECT COUNT(*)
    INTO l_w_count
    FROM  ZEN_B2B_JSON_SO
    WHERE STATUS = 'W';

    IF l_w_count  = 0 THEN
      -- No records with status 'W' to process.
      -- We raise a  specific application error.
      -- The calling application (e.g., Java) can catch this specific error code
       -- and interpret it as a signal to gracefully exit the process
      -- instead of treating it as an unexpected failure.
       RAISE_APPLICATION_ERROR(-20001, 'No records to process (status=W).');
    END  IF;
  END;
end;
```
Please ensure this script is executed after all data extraction scripts and prior to initiating the JSON mapping logic.


**Crafting the Pre-Check**

I'm now generating a new SQL script named `pre_mapping_check.sql` located within the `src/main/resources/sql` directory. This script incorporates the requested 'W' status check within a PL/SQL anonymous block. The primary goal is to determine if any records within the `ZEN_B2B_JSON_SO` table possess a status of 'W'. If no such records are identified, an application error will be triggered, enabling the calling application to handle the condition accordingly.

\n\n```sql
-- src/main/resources/sql/pre_mapping_check.sql
DECLARE
  l_w_count NUMBER;
BEGIN
  SELECT COUNT(*)
  INTO l_w_count
  FROM ZEN_B2B_JSON_SO
  WHERE STATUS = 'W';

  IF l_w_count = 0 THEN
    -- No records to process.
    RAISE_APPLICATION_ERROR(-20001, 'No records to process (status=W).');
  END IF;
END;
/
```
Please execute this script after all data extraction processes have completed and prior to initiating the JSON mapping.


</details></think>

---

好的，我了解您的需求。我將新增一個 SQL 腳本，用於在進行 JSON 映射之前檢查是否存在狀態為 'W' 的待處理資料。

這個新腳本將會查詢 `ZEN_B2B_JSON_SO` 表，計算 `STATUS = 'W'` 的紀錄筆數。如果筆數為 0，它會拋出一個應用程式錯誤。您的應用程式（例如 Java）可以捕捉這個特定的錯誤，並將其視為一個無需繼續處理的信號，從而優雅地跳過後續的 JSON 映射流程並結束程式。

請在您現有的執行流程中，於所有資料抽取 (`extract` scripts) 完成後、進行 JSON 映射前，執行此腳本。

我將為您建立 `src/main/resources/sql/pre_mapping_check.sql` 檔案，內容如下：

```sql:src/main/resources/sql/pre_mapping_check.sql
DECLARE
  l_w_count NUMBER;
BEGIN
  SELECT COUNT(*)
  INTO l_w_count
  FROM ZEN_B2B_JSON_SO
  WHERE STATUS = 'W';

  IF l_w_count = 0 THEN
    RAISE_APPLICATION_ERROR(-20001, 'No records with status ''W'' to process.');
  END IF;
END;
```

這樣，您就可以在您的主流程中整合這個檢查步驟了。

---

_**User**_

@Codebase  除了SQL以外，其他的也請你生成對應的程式碼

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Assessing the Pre-Mapping**

I'm now focusing on implementing the pre-mapping check. I've designed the SQL query to select records from `ZEN_B2B_JSON_SO` where the `STATUS` is 'W'. This query will be the core of the check. I'm also preparing the counter logic to determine if the result set is greater than zero to decide whether to process the JSON.


**Integrating the Pre-Check**

I've determined the optimal placement for the pre-mapping check within the application flow. It will be implemented before the existing data extraction and loading processes, directly in `DbExtractRunner`.  The count will determine whether the subsequent mapping and error notification logic is executed. This should prevent unnecessary processing when no relevant records exist.


**Orchestrating the Pre-Check**

I'm now in the process of incorporating the SQL query into the Java application. I've pinpointed `DbExtractRunner` as the correct entry point.  My strategy involves creating a service method to execute the SQL script, and subsequently integrate this service method into the `DbExtractRunner`.  I will also incorporate the logic to handle the graceful exit when no records are found and when an exception occurs.


**Adding the SQL Execution**

I'm currently incorporating the SQL execution into the `DbExtractRunner` flow. I plan to introduce a method to interact with the database using the SQL query. The goal is to gracefully handle the exit when the query returns no records, preventing unnecessary processing. I'm focusing on exception handling to ensure the application exits cleanly in such cases.


**Developing the Pre-Check Service**

I'm now in the process of creating a `PreMappingCheckService` to encapsulate the pre-mapping logic. I've designed a method to execute the SQL query using `JdbcTemplate` and handle the resulting `SQLException` from the database. This approach will allow for graceful program termination if no suitable records are found. I'm focusing on ensuring proper error handling and logging to maintain application stability.


**Establishing the Pre-Check Service**

I've crafted a `PreMappingCheckService` class and plan to integrate it with the `DbExtractRunner`. The service will execute the `pre_mapping_check.sql` script to determine if processing should proceed. I'm focusing on handling exceptions gracefully to manage scenarios with and without data effectively.


**Incorporating the Service**

I've integrated the `PreMappingCheckService` into `DbExtractRunner` to execute the pre-mapping check. The application now calls the service before proceeding with data loading. The logic handles the expected `SQLException` raised by `RAISE_APPLICATION_ERROR` in the SQL script, allowing the program to exit gracefully if no records are found. I've ensured appropriate logging for different scenarios.


**Orchestrating the Pre-Check**

I've integrated the `PreMappingCheckService` into the main application flow within the `DbExtractRunner`. The program now executes the service, which in turn calls the SQL script. This is followed by a check to determine whether the program should continue processing, and the graceful handling of the expected exception raised by the SQL query. The code will halt immediately if no records are found and proper logging is in place.


**Orchestrating the Pre-Check**

I've integrated the `PreMappingCheckService` into the `DbExtractRunner`'s flow. It's now checking for records with status 'W' before proceeding. The application exits gracefully if no records are found, ensuring the expected behavior. I've added a placeholder comment for the JSON mapping logic.


**Orchestrating the Pre-Check**

I've integrated the `PreMappingCheckService` into the `DbExtractRunner`'s flow. It's now checking for records with status 'W' before proceeding with mapping. The application exits gracefully if no records are found, ensuring the expected behavior. I've added a placeholder comment for the JSON mapping logic.


**Validating Pre-Check Integration**

I've ensured the graceful exit functionality operates as intended within the `DbExtractRunner`. The program will exit automatically if the `preMappingCheckService` determines that no 'W' status records exist. I will soon add the JSON mapping logic.

**Verifying Pre-Check Integration**

I've concluded integrating the `PreMappingCheckService` into the `DbExtractRunner`, ensuring it functions as anticipated. The application now gracefully exits when no records with the 'W' status are present, aligning with the expected behavior. I've placed the placeholder comment for JSON mapping.


**Validating Pre-Check Integration**

I've meticulously integrated the `PreMappingCheckService` into the `DbExtractRunner`, verifying the program now terminates gracefully when no 'W' status records are found. The logging provides informative feedback on program termination. Next, I'll incorporate the JSON mapping logic.


**Validating Pre-Check Integration**

I've finalized the `PreMappingCheckService` integration within the `DbExtractRunner`, ensuring a graceful program exit if no 'W' status records are found, as anticipated. I've also incorporated the necessary logging for transparency. Moving forward, I'll turn my focus toward developing the core JSON mapping logic.


**Refining Pre-Check Implementation**

I've made the necessary code adjustments to integrate the pre-mapping check into `DbExtractRunner`, incorporating the `PreMappingCheckService`. The application now verifies the presence of 'W' status records before proceeding. I've also verified the SQL file's code. Further enhancements include logging to facilitate effective error tracking during execution.


**Refining Pre-Check Implementation**

I've reviewed the `PreMappingCheckService` integration within `DbExtractRunner`, and now it's logging the successful program termination. I've updated both the `pre_mapping_check.sql` file and the `PreMappingCheckService` class to ensure the application behaves correctly when no records with status 'W' are found. I have also added comprehensive logging and added the necessary imports.


**Integrating the Pre-Check**

I've integrated the `PreMappingCheckService` into the main application flow. Now, the application first checks for records with status 'W' before proceeding. If none are found, the program will terminate gracefully, fulfilling the user's initial request. I've also added comprehensive logging to track the execution steps for easy debugging.

**Implementing the Pre-Check**

I've integrated the `PreMappingCheckService` into the main application flow. Now, it determines if there are 'W' status records. If not, the program exits gracefully with clear logging. I've placed the placeholder comment for JSON mapping. Now, the application flow is complete.


**Validating the Implementation**

I've now incorporated the SQL query check and service into the `DbExtractRunner`, completing the initial integration. The application will now gracefully exit if no 'W' status records are found, as per the user's requirements.  I've also addressed redundant logging.


**Validating the Integration**

I've carefully integrated the `PreMappingCheckService` into the `DbExtractRunner`, verifying that the program gracefully exits when no 'W' status records are present. Comprehensive logging is implemented for clear termination feedback. The focus now shifts to the essential JSON mapping logic.


**Verifying Pre-Check Implementation**

I'm now in the process of validating the changes within the main `DbExtractRunner` flow. I've placed the logic to check for the 'W' status records after the notifications are sent. I've also added the corresponding log entry and the necessary return. Everything seems to be operating as expected.

**Verifying the Pre-Check**

I've made the necessary adjustments to incorporate the pre-mapping check into the application. Specifically, the program now terminates if no records with the 'W' status are found. The logging provides clear feedback on the application's termination. I will next focus on the JSON mapping logic as the core functionality.


</details></think>

---

好的，我將為您產生對應的 Java 程式碼，並將其整合到現有的應用程式流程中。

這將包含三個部分：
1.  建立新的 SQL 檔案 `pre_mapping_check.sql`，用於檢查待處理資料。
2.  建立一個新的服務 `PreMappingCheckService` 來執行此 SQL 檢查。
3.  修改主執行緒 `DbExtractRunner` 來呼叫新服務，並根據檢查結果決定是否繼續執行後續的 Mapping 任務。

首先，我將建立 `pre_mapping_check.sql` 檔案。

```sql:src/main/resources/sql/pre_mapping_check.sql
DECLARE
  l_w_count NUMBER;
BEGIN
  SELECT COUNT(*)
  INTO l_w_count
  FROM ZEN_B2B_JSON_SO
  WHERE STATUS = 'W';

  IF l_w_count = 0 THEN
    -- 拋出一個自定義的應用程式錯誤。
    -- Java 應用程式會捕捉這個錯誤碼並正常結束程式。
    RAISE_APPLICATION_ERROR(-20001, '沒有狀態為 ''W'' 的資料需要處理。');
  END IF;
END;
```

接著，是新的 `PreMappingCheckService`，它會執行上面的 SQL。

```java:src/main/java/com/znt/outbound/service/PreMappingCheckService.java
package com.znt.outbound.service;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.ResourceLoader;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.sql.SQLException;

@Service
@RequiredArgsConstructor
@Slf4j
public class PreMappingCheckService {

    private final JdbcTemplate jdbcTemplate;
    private final ResourceLoader resourceLoader;

    /**
     * 檢查 ZEN_B2B_JSON_SO 表中是否有狀態為 'W' 的紀錄。
     * @return 如果有待處理紀錄則返回 true，否則返回 false。
     */
    public boolean hasRecordsToProcess() {
        log.info(">>> 正在檢查是否有狀態為 'W' 的待處理資料...");

        String plsql;
        try (InputStream is = resourceLoader.getResource("classpath:sql/pre_mapping_check.sql").getInputStream()) {
            plsql = new String(is.readAllBytes(), StandardCharsets.UTF_8);
        } catch (IOException e) {
            log.error(">>> 無法讀取 pre_mapping_check.sql 檔案。", e);
            throw new IllegalStateException("無法讀取 pre_mapping_check.sql", e);
        }

        try {
            jdbcTemplate.execute(plsql);
            log.info(">>> 發現待處理資料，準備執行下一步。");
            return true;
        } catch (DataAccessException e) {
            Throwable rootCause = e.getRootCause();
            if (rootCause instanceof SQLException sqlEx) {
                if (sqlEx.getErrorCode() == 20001) {
                    log.info(">>> {}", sqlEx.getMessage());
                    return false;
                }
            }
            log.error(">>> 執行 pre_mapping_check.sql 時發生非預期的資料庫錯誤。", e);
            throw e;
        }
    }
}
```

最後，我將修改 `DbExtractRunner` 來使用這個新服務。

```java:src/main/java/com/znt/outbound/runner/DbExtractRunner.java
package com.znt.outbound.runner;

import com.znt.outbound.service.GenericExtractService;
import com.znt.outbound.service.LoadService;
import com.znt.outbound.service.NotificationService;
import com.znt.outbound.service.PreMappingCheckService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.CommandLineRunner;
import org.springframework.stereotype.Component;

@Component      
@RequiredArgsConstructor
@Slf4j
public class DbExtractRunner implements CommandLineRunner {

    private final GenericExtractService extractService;
    private final LoadService loadService;
    private final NotificationService notificationService;
    private final PreMappingCheckService preMappingCheckService;

    @Override
    public void run(String... args) {
        log.info(">>> 開始執行資料庫抽取與載入任務...");
        int extractedCount = extractService.extract();

        if (extractedCount > 0) {
            log.info(">>> 已抽取 {} 筆資料至暫存表，準備載入正式表...", extractedCount);
            loadService.loadFromTmpToMain();
            log.info(">>> 資料載入任務完成。");
        } else {
            log.info(">>> 暫存表中無新資料。");
        }

        // 無論是否有新資料，都檢查並寄送錯誤通知
        try {
            notificationService.sendErrorNotifications();
        } catch (Exception e) {
            log.error(">>> 執行郵件通知任務時發生嚴重錯誤。", e);
        }

        // 新增：檢查是否有狀態為 'W' 的待處理資料
        if (!preMappingCheckService.hasRecordsToProcess()) {
            log.info(">>> 所有任務執行完畢 (沒有需要 Mapping 的資料)。");
            return; // 結束執行
        }

        // TODO: 在這裡加入後續的 JSON mapping 程式碼
        log.info(">>> 準備開始執行 JSON Mapping 任務...");


        log.info(">>> 所有任務執行完畢。");
    }
}
```

這樣，應用程式在每次執行時，都會在資料載入後、進行 Mapping 之前，先檢查是否有狀態為 `W` 的資料。如果沒有，程式將會記錄一條訊息然後乾淨地退出，不會執行後續的 Mapping 步驟。

---


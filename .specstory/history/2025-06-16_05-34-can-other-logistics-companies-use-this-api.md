<!-- Generated by SpecStory -->

# Can other logistics companies use this API? (2025-06-16 13:34:20)

_**User**_

@Codebase 目前整個專案，若現在其他物流商(不是FEILIKS)要直接套用這個API是可以的嗎?

---

_**Assistant**_



---

好的，這是一個很好的問題，關係到專案的架構和擴充性。

我分析了整個專案的程式碼後，結論是：**目前無法直接套用給其他物流商。**

目前的實作與 `FEILIKS` 這家物流商的 API 規格**高度耦合 (Tightly Coupled)**。如果想支援新的物流商，需要進行一定程度的重構和開發。

以下是幾個主要的原因：

### 1. 資料模型 (Data Models) 完全客製化

專案中的 `model` 套件（`com.znt.outbound.model`）底下的所有類別，都是完全針對 `FEILIKS` 的 JSON 格式設計的。

*   **請求模型**: `FeiliksRequest`, `FeiliksData`, `FeiliksOrder`, `FeiliksOrderList`, `FeiliksShippingInstruction` 這些類別的欄位名稱（使用 `@JsonProperty`）、層級結構，都完全對應 `FEILIKS` 的 API 文件。其他物流商的 API 格式幾乎不可能一模一樣。
*   **回應模型**: `FeiliksResponseDto` 用來解析 `FEILIKS` 回傳的結果 (`{ "success": true, ... }`)。新的物流商會有自己的回應格式。

### 2. 業務邏輯與對應服務 (Mapping Logic) 寫死

`JsonMappingService` 是將你們系統內部資料轉換成 `FEILIKS` API 格式的核心。

*   `buildRequest()` 方法的目標就是建立一個 `FeiliksRequest` 物件。
*   `mapHeaderToOrder()`、`getOrderListsByInvoiceNo()` 等方法，裡面的邏輯都是為了組裝出 `FeiliksOrder` 和 `FeiliksOrderList` 等特定物件。
*   另一家物流商需要的欄位、資料轉換規則都會不同，所以整個 `JsonMappingService` 的邏輯都需要為新的物流商重寫。

### 3. 認證機制 (Authentication) 特定

`JsonMappingService` 中的 `generateSign()` 方法，使用了 `dataJson + secretKey` 進行 MD5 加密來產生簽章。這是 `FEILIKS` 特有的認證方式。

其他物流商可能會使用不同的簽章演算法、OAuth 2.0、或是簡單地在 HTTP Header 中放入 API Key 等不同的認證方法。

### 4. API 設定 (Configuration) 寫死

`ApiConfigService` 在初始化時，會從資料庫查詢 `TD_NO` 為 `FEILIKS-APPID`, `FEILIKS-APPKEY`, `FEILIKS-SO_URLT` 的設定。

如果要新增一家物流商，例如 `DHL`，就需要修改這段程式碼來讀取 `DHL-APPID` 等對應的設定。

### 結論與建議

目前的架構是「為 `FEILIKS` 寫死的一個 API 客戶端」。若要支援多家物流商，建議進行以下重構，導入**策略模式 (Strategy Pattern)**：

1.  **定義通用介面 (Interface)**：
    建立一個例如 `LogisticsProvider` 或 `ApiClient` 的介面，定義所有物流商都需要實現的共同行為。
    ```java
    public interface LogisticsProvider {
        // T 是該服務商特定的請求物件，R 是特定的回應物件
        <T, R> R sendOrder(T request);
        
        // 從內部資料模型建立該服務商的請求
        Object buildRequestFromInternalData(List<SoHeaderDto> headers);
        
        // 解析回應
        boolean isResponseSuccess(Object response);
    }
    ```

2.  **建立具體的實作類別**：
    為每個物流商建立一個實作該介面的類別。
    *   `FeiliksApiClient`：將現有的 `ApiService` 和 `JsonMappingService` 的邏輯搬移並整合進來。
    *   `DhlApiClient` (未來新增)：為 DHL 實作它自己的資料轉換、簽章和 API 呼叫邏輯。

3.  **使用工廠模式 (Factory Pattern) 來選擇實作**：
    建立一個工廠類別，根據訂單或其他條件，決定要使用哪一個物流商的 `ApiClient` 實作。

透過這樣的重構，未來要增加新的物流商時，只需要新增一個實作 `LogisticsProvider` 介面的類別，而不需要修改到核心的業務流程，會讓系統更有彈性與擴充性。

---

_**User**_

@Codebase  因為目前另一家物流商 (JIT) 願意使用跟FEILIKS一樣的Spec，未來要改的應該只有API調用的網址跟PART_CODE及Key。
那這樣未來是否可以直接套用?

---


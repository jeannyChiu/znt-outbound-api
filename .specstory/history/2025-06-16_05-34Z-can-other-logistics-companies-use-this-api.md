<!-- Generated by SpecStory -->

# Can other logistics companies use this API? (2025-06-16 05:34Z)

_**User**_

@Codebase 目前整個專案，若現在其他物流商(不是FEILIKS)要直接套用這個API是可以的嗎?

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Exploring API Adaptability**

I'm currently breaking down the user's question, focusing on the feasibility of adapting the existing "FEILIKS" API integration for other logistics providers. My initial thought is to identify the core components of the current integration and assess their provider-specific nature. I'll need to dissect the codebase to see how adaptable the authentication, data handling, and error management are.


**Dissecting Codebase Specificity**

I'm currently focused on the `model/json` package. My analysis of `FeiliksRequest.java`, `FeiliksData.java`, `FeiliksOrder.java`, `FeiliksOrderList.java`, and `FeiliksShippingInstruction.java` confirms my suspicion: these data models are highly coupled to "FEILIKS"'s API structure. The core challenge will be mapping different providers' data structures to a common, abstracted model. This will likely involve a significant refactor to introduce adapters or a translation layer.


**Refining Abstraction Strategies**

I've been analyzing the `service` package, specifically `ApiConfigService.java`. The way it fetches "FEILIKS" specific keys from the database confirms my earlier assessment: the configuration is tightly coupled. I'm starting to think about strategies for abstracting this configuration. Perhaps a provider-specific configuration factory or a lookup table could introduce the necessary flexibility. The goal is to move towards a more pluggable architecture where adding a new provider requires minimal modifications to the core integration logic.


**Examining Data Abstraction**

I'm now focusing on the `JsonMappingService`. While the data retrieval from the local database seems generic, the subsequent mapping logic heavily relies on `FeiliksOrder`, `FeiliksOrderList`, and `FeiliksShippingInstruction`.  I realize a significant refactor is needed. Creating abstract interfaces for order data and employing a factory pattern to handle provider-specific data mapping will be crucial. This shift will allow us to introduce new providers with less effort in the future.


**Reflecting on Adaptability Barriers**

I'm now fully immersed in the nuances of the codebase's adaptability. My analysis highlights significant challenges: the pervasive coupling to "FEILIKS" data structures and API contracts across the `model/json` and `service` packages. A complete rework of the mapping and signing strategies is inevitable. I'm exploring patterns like the strategy or factory to begin isolating provider-specific elements.


**Identifying Key Coupling Points**

I'm now fully immersed in the codebase analysis. My initial assessment is confirmed: the project is tightly coupled to the "FEILIKS" API. I've identified specific areas of strong coupling within the data models, configuration loading, and, most importantly, the JSON mapping logic. The hardcoded key prefixes and data structure dependencies indicate that direct application to another provider is not feasible without significant refactoring.


**Reflecting on Adaptation Feasibility**

I'm now concluding that direct application is impossible. The data models and mapping are "FEILIKS" specific, and the signing and configuration are tightly coupled. To make this adaptable, I must refactor to abstract data models and implement provider-specific adapters and configuration. This is key to enabling flexibility for other providers.


**Analyzing Core Integration Elements**

I'm currently focused on the `service` package's coupling to "FEILIKS." My initial assessment confirmed its provider-specific design. `ApiConfigService.java` is tightly coupled to the "FEILIKS" API. I plan to identify potential interfaces and abstract classes to build a more adaptable solution.


**Evaluating API Adaptability**

I'm currently focused on the feasibility of adapting the "FEILIKS" API integration to different providers. Initial analysis reveals a strong coupling between the existing code and "FEILIKS" specifications. I'm exploring potential abstraction strategies to enhance the codebase's flexibility for future integrations.


</details></think>

---

好的，這是一個很好的問題，關係到專案的架構和擴充性。

我分析了整個專案的程式碼後，結論是：**目前無法直接套用給其他物流商。**

目前的實作與 `FEILIKS` 這家物流商的 API 規格**高度耦合 (Tightly Coupled)**。如果想支援新的物流商，需要進行一定程度的重構和開發。

以下是幾個主要的原因：

### 1. 資料模型 (Data Models) 完全客製化

專案中的 `model` 套件（`com.znt.outbound.model`）底下的所有類別，都是完全針對 `FEILIKS` 的 JSON 格式設計的。

*   **請求模型**: `FeiliksRequest`, `FeiliksData`, `FeiliksOrder`, `FeiliksOrderList`, `FeiliksShippingInstruction` 這些類別的欄位名稱（使用 `@JsonProperty`）、層級結構，都完全對應 `FEILIKS` 的 API 文件。其他物流商的 API 格式幾乎不可能一模一樣。
*   **回應模型**: `FeiliksResponseDto` 用來解析 `FEILIKS` 回傳的結果 (`{ "success": true, ... }`)。新的物流商會有自己的回應格式。

### 2. 業務邏輯與對應服務 (Mapping Logic) 寫死

`JsonMappingService` 是將你們系統內部資料轉換成 `FEILIKS` API 格式的核心。

*   `buildRequest()` 方法的目標就是建立一個 `FeiliksRequest` 物件。
*   `mapHeaderToOrder()`、`getOrderListsByInvoiceNo()` 等方法，裡面的邏輯都是為了組裝出 `FeiliksOrder` 和 `FeiliksOrderList` 等特定物件。
*   另一家物流商需要的欄位、資料轉換規則都會不同，所以整個 `JsonMappingService` 的邏輯都需要為新的物流商重寫。

### 3. 認證機制 (Authentication) 特定

`JsonMappingService` 中的 `generateSign()` 方法，使用了 `dataJson + secretKey` 進行 MD5 加密來產生簽章。這是 `FEILIKS` 特有的認證方式。

其他物流商可能會使用不同的簽章演算法、OAuth 2.0、或是簡單地在 HTTP Header 中放入 API Key 等不同的認證方法。

### 4. API 設定 (Configuration) 寫死

`ApiConfigService` 在初始化時，會從資料庫查詢 `TD_NO` 為 `FEILIKS-APPID`, `FEILIKS-APPKEY`, `FEILIKS-SO_URLT` 的設定。

如果要新增一家物流商，例如 `DHL`，就需要修改這段程式碼來讀取 `DHL-APPID` 等對應的設定。

### 結論與建議

目前的架構是「為 `FEILIKS` 寫死的一個 API 客戶端」。若要支援多家物流商，建議進行以下重構，導入**策略模式 (Strategy Pattern)**：

1.  **定義通用介面 (Interface)**：
    建立一個例如 `LogisticsProvider` 或 `ApiClient` 的介面，定義所有物流商都需要實現的共同行為。
    ```java
    public interface LogisticsProvider {
        // T 是該服務商特定的請求物件，R 是特定的回應物件
        <T, R> R sendOrder(T request);
        
        // 從內部資料模型建立該服務商的請求
        Object buildRequestFromInternalData(List<SoHeaderDto> headers);
        
        // 解析回應
        boolean isResponseSuccess(Object response);
    }
    ```

2.  **建立具體的實作類別**：
    為每個物流商建立一個實作該介面的類別。
    *   `FeiliksApiClient`：將現有的 `ApiService` 和 `JsonMappingService` 的邏輯搬移並整合進來。
    *   `DhlApiClient` (未來新增)：為 DHL 實作它自己的資料轉換、簽章和 API 呼叫邏輯。

3.  **使用工廠模式 (Factory Pattern) 來選擇實作**：
    建立一個工廠類別，根據訂單或其他條件，決定要使用哪一個物流商的 `ApiClient` 實作。

透過這樣的重構，未來要增加新的物流商時，只需要新增一個實作 `LogisticsProvider` 介面的類別，而不需要修改到核心的業務流程，會讓系統更有彈性與擴充性。

---

_**User**_

@Codebase  因為目前另一家物流商 (JIT) 願意使用跟FEILIKS一樣的Spec，未來要改的應該只有API調用的網址跟PART_CODE及Key。
那這樣未來是否可以直接套用?

---

_**Assistant**_

<think><details><summary>Thought Process</summary>**Clarifying API Adoption**

I'm now focusing on a follow-up query. It appears another logistics provider, JIT, has agreed to adopt the same API specification as FEILIKS. This agreement clarifies the implications for my understanding. Specifically, the JSON structure for requests like FeiliksRequest, FeiliksData, and FeiliksOrder will remain consistent. This simplifies the implementation plan.


**Reassessing Project Applicability**

I've been re-evaluating the project's direct applicability to JIT.  The consistent JSON structure across FEILIKS and JIT, including requests and responses, significantly simplifies matters.  While the data models, mapping logic, and authentication components appear reusable, I'm now focusing on adapting the configuration, specifically endpoints, `part_code`, and secret keys, to suit JIT's requirements. This suggests a more straightforward implementation than initially anticipated.


**Modifying for Provider Agnosticism**

I'm now focusing on adapting the configuration. Given the API spec consistency, key adaptations involve moving beyond the current singleton `ApiConfigService`. The aim is now supporting both providers, which will require a mechanism, such as dynamic configuration lookups or provider-specific configuration loading, that allows choosing the correct set of API keys and endpoints at runtime. The data models, mapping logic, and authentication components appear reusable with minor adjustments for generic naming.


**Restructuring Configuration Logic**

I'm now focusing on a more dynamic configuration approach. Given the identical API specification between FEILIKS and JIT, the data models and mapping logic can indeed be reused with minimal alterations, which is a significant simplification. However, the current singleton `ApiConfigService`, hardcoded for FEILIKS, remains the central obstacle. To support both providers, it needs a refactor. I'm exploring moving to a `getConfigForProvider(String providerName)`-style method, enabling runtime configuration selection. This shift will make the system more flexible and adaptable.


**Expanding Configuration Scope**

I'm now refining the approach.  The consistent API spec between FEILIKS and JIT is a game-changer. Reusing the models, the mapping logic, and authentication are all feasible. The bottleneck is the hardcoded configuration. I'm exploring a dynamic, provider-agnostic `ApiConfigService`, using a map to hold provider-specific configuration. Then, services using the config would specify the provider name. The implementation sketch involves a `Map<String, ApiProviderConfig>` for runtime lookup.


**Transitioning to Config-Driven Services**

I'm now focusing on a follow-up implementation. While the API spec consistency simplifies the models and mapping, the hardcoded configuration remains a hurdle. My current focus is implementing a provider-agnostic `ApiConfigService`, using a map to hold provider-specific configurations. Adapting services to specify the provider name at runtime will make it a lot easier. This dynamic approach ensures a smoother and more robust design.


**Enhancing Config Adaptability**

I'm now focusing on a more flexible design. With the consistent API spec, I'll update the `ApiConfigService` to support multiple providers, using a lookup map. Services using the config will need the provider name to look up the correct configuration. I'm focusing on tracing the existing service flow to identify where provider selection occurs. The current code suggests that determining the provider is possible at the database level.


**Streamlining Configuration Logic**

I'm now focusing on a more flexible design. The consistent API spec between FEILIKS and JIT simplifies matters, allowing reuse of models, mapping logic, and authentication.  My focus is updating the `ApiConfigService` to support multiple providers, using a provider name-based lookup. I'm prioritizing tracing the service flow to identify where provider selection occurs, possibly at the database level.


**Streamlining for Dual-Provider Support**

The shared API spec is a game-changer! It allows me to reuse models and mapping logic. The `ApiConfigService`, however, is a hurdle. Adapting this service to manage provider-specific configurations dynamically, using a lookup map, will support both FEILIKS and JIT. I will trace the service flow to ensure provider selection at runtime.


**Adjusting for Provider Diversity**

I'm now focusing on a more flexible design. With the consistent API spec, I'll update the `ApiConfigService` to support multiple providers, using a lookup map. Services using the config will need the provider name to look up the correct configuration. I'm focusing on tracing the existing service flow to identify where provider selection occurs. The current code suggests that determining the provider is possible at the database level.


**Refining Provider Adaptability**

I'm now focusing on a more flexible design. The consistent API spec between FEILIKS and JIT simplifies things, allowing reuse of models, mapping logic, and authentication.  My focus is updating the `ApiConfigService` to support multiple providers, using a provider name-based lookup. I'm prioritizing tracing the service flow to identify where provider selection occurs, possibly at the database level.


**Simplifying Configuration Adoption**

I'm now focusing on a more streamlined approach. With the shared API spec, I've confirmed that models, mapping, and authentication remain reusable. The primary challenge, the static configuration in `ApiConfigService`, now focuses on a dynamic, property-driven approach. I'll utilize Spring profiles to select configuration at runtime, making it more flexible and easier to maintain. This simplifies the previous refactoring, and ensures the code will adapt for any future changes.


**Simplifying Configuration for JIT**

I'm now focusing on a follow-up implementation. While the API spec consistency simplifies the models and mapping, the hardcoded configuration remains a hurdle. My current focus is implementing a provider-agnostic `ApiConfigService`, using a map to hold provider-specific configurations. Adapting services to specify the provider name at runtime will make it a lot easier. This dynamic approach ensures a smoother and more robust design.



</details></think>

---

您好，感謝您的補充說明。

如果新的物流商 (JIT) 願意完全採用與 `FEILIKS` 相同的 API 規格（包含 JSON 結構、簽章演算法等），那情況就樂觀得多，**確實絕大部分的程式碼都可以直接套用**。

您說的沒錯，未來要修改的應該只有 API 的 URL、Part Code 和 Key。

不過，目前的程式碼在讀取這些設定時是**寫死的 (Hardcoded)**。這也是唯一需要修改的地方。

### 核心問題：寫死的設定

問題點主要在 `ApiConfigService.java` 這個檔案。它在啟動時會去資料庫撈取設定，但它尋找的鍵值 (key) 是固定的 `FEILIKS-*`：

```java:src/main/java/com/znt/outbound/service/ApiConfigService.java
// ...
this.partCode = configMap.get("FEILIKS-APPID");
this.secretKey = configMap.get("FEILIKS-APPKEY");
this.apiUrl = configMap.get("FEILIKS-SO_URLT");
// ...
```

這意味著目前的程式碼一次只能為 `FEILIKS` 服務。

### 解決方案：動態載入設定

我們可以對 `ApiConfigService` 做一點小修改，讓它可以根據一個外部設定來決定要載入哪家物流商的資料。這樣就不需要動到其他如 `JsonMappingService` 或 `ApiService` 的程式碼了。

這是一個侵入性最小、最簡單的作法。

**步驟 1: 修改 `ApiConfigService`**

我們讓它從 Spring Boot 的設定檔 (`application.properties`) 讀取一個我們自訂的屬性 `logistics.provider.name`，並用這個屬性來動態產生要查詢的鍵值。

```java:src/main/java/com/znt/outbound/service/ApiConfigService.java
package com.znt.outbound.service;

import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class ApiConfigService {

    private final JdbcTemplate jdbcTemplate;

    @Value("${logistics.provider.name:FEILIKS}")
    private String providerName;

    private String partCode;
    private String secretKey;
    private String apiUrl;

    @PostConstruct
    public void init() {
        log.info("正在為物流商 '{}' 從資料庫載入 API 設定...", providerName);
        String sql = "SELECT TD_NO, TD_NAME FROM ZEN_B2B_TAB_D WHERE T_NO = 'JSON_SYS_INFO'";
        try {
            List<Map<String, Object>> rows = jdbcTemplate.queryForList(sql);

            // 將查詢結果轉換為 Map 以方便取值
            Map<String, String> configMap = rows.stream()
                .filter(row -> row.get("TD_NO") != null && row.get("TD_NAME") != null)
                .collect(Collectors.toMap(
                    row -> row.get("TD_NO").toString(),
                    row -> row.get("TD_NAME").toString()
                ));

            this.partCode = configMap.get(providerName + "-APPID");
            this.secretKey = configMap.get(providerName + "-APPKEY");
            this.apiUrl = configMap.get(providerName + "-SO_URLT");

            if (this.partCode == null || this.secretKey == null || this.apiUrl == null) {
                log.error("在資料庫中找不到 '{}' 的必要 API 設定 ({}-APPID, {}-APPKEY, 或 {}-SO_URLT)。",
                          providerName, providerName, providerName, providerName);
                throw new IllegalStateException("無法初始化 API 設定，請檢查 ZEN_B2B_TAB_D 資料表中的 TD_NAME 欄位。");
            }
            log.info("API 設定載入成功。Provider: {}, URL: {}, Part Code: {}, Secret Key: (已隱藏)",
                    providerName, this.apiUrl, this.partCode);

        } catch (Exception e) {
            log.error("從資料庫載入 API 設定失敗。", e);
            throw new RuntimeException("無法從資料庫載入 API 設定。", e);
        }
    }

// ... getter 方法維持不變 ...
// ... existing code ...
```

**步驟 2: 新增 JIT 的資料庫設定**

請在您的 `ZEN_B2B_TAB_D` 資料表中，為 JIT 新增對應的設定：
*   `JIT-APPID`
*   `JIT-APPKEY`
*   `JIT-SO_URLT`

**步驟 3: 執行應用程式時指定物流商**

完成以上修改後，當您要為 JIT 執行這個 API 時，只需要在執行程式時傳入參數即可。例如：

*   **透過 `application.properties` 設定:**
    ```properties
    logistics.provider.name=JIT
    ```
*   **或透過命令列參數:**
    ```bash
    java -jar your-application.jar --logistics.provider.name=JIT
    ```

如果不提供這個參數，程式會使用 `@Value("${logistics.provider.name:FEILIKS}")` 中的預設值 `FEILIKS`，確保了向下相容。

### (可選) 長期維護建議

為了讓程式碼語意更清晰，未來可以考慮將所有 `Feiliks` 開頭的 Java 類別（如 `FeiliksRequest`, `FeiliksOrder`）重構成更通用的名稱（如 `LogisticsApiRequest`, `LogisticsApiOrder`）。

這不是必要步驟，程式碼在完成上述修改後就能正常運作，但好的命名能讓未來的維護者更容易理解程式碼的用途。

總結來說，您的情況非常理想，只需要很小的改動就可以支援新的物流商。

---

